#!/usr/bin/env ruby

$:.push(File.dirname($0))
require 'optparse'
require 'socket'

$options = {
  :config_filename => ENV['HOME'] + "/.kestrel_cluster",
  :server_list => [],
  :port => 22133,
}

def fetch_stats(host, port, data)
  puts "--- Fetching stats from #{host}:#{port}"
  sock = TCPSocket.open(host, port)
  sock.puts("stats")
  done = false
  while !done && line = sock.gets.chomp
    if (line == 'END') then
      done = true
    elsif line =~ /STAT queue_(\w+) (\d+)/
      key = $1
      value = $2.to_i
      if key =~ /(\w+)_total_items/
        data[:total_items][$1] += value
      elsif key =~ /(\w+)_items/
        data[:items][$1] += value
      elsif key =~ /(\w+)_mem_bytes/
        data[:mem_bytes][$1] += value
      elsif key =~ /(\w+)_bytes/
        data[:bytes][$1] += value
      elsif key =~ /(\w+)_age/
        data[:min_age][$1] = value if value < data[:min_age][$1]
        data[:max_age][$1] = value if value > data[:max_age][$1]
      end
    end
  end
  sock.close
end

def fetch_all
  data = Hash.new do |h, data_type|
    h[data_type] = Hash.new do |h, k|
      h[k] = (data_type == :min_age) ? 2**31 : 0
    end
  end
  $options[:server_list].each do |server|
    begin
      fetch_stats(server, $options[:port], data)
    rescue => e
      puts "Could not connect to host #{server}: #{e}"
    end
  end
  data
end

def sort_data(data)
  rv = {}
  data.each { |key, v| rv[key] = v.sort_by { |h| [ h[1], h[0] ] } }
  rv
end

def report(data, key)
  puts ""
  format = "%14s %s\n"
  printf(format, key, "queue")
  printf(format, "============", "====================")
  data[key].each { |queue, value| printf("%14d %s\n", value, queue) }
end

def report_all(data, keys)
  keys.each { |key| report(data, key) }
  puts ""
end

def delete_all(queue_name)
  $options[:server_list].each do |server|
    print "--- Deleting queue #{queue_name} from #{server}:#{$options[:port]} ... "
    STDOUT.flush
    sock = TCPSocket.open(server, $options[:port])
    sock.puts("delete " + queue_name)
    puts sock.readline.chomp
    sock.close
  end
  puts "Done."
end

def flush_all(queue_name)
  $options[:server_list].each do |server|
    print "--- Flushing queue #{queue_name} from #{server}:#{$options[:port]} ... "
    STDOUT.flush
    sock = TCPSocket.open(server, $options[:port])
    sock.puts("flush " + queue_name)
    puts sock.readline.chomp
    sock.close
  end
  puts "Done."
end

def keep_unchanged_data(last, current)
  rv = {}
  current.keys.each { |key| rv[key] = keep_unchanged_hash(last[key], current[key]) }
  rv
end

def keep_unchanged_hash(last, current)
  rv = {}
  last.each do |key, value|
    rv[key] = value if current[key] == value
  end
  rv
end

# dump queues that appear to have neither :items nor :total_items changing.
def find_stale(rounds)
  puts "Check 1..."
  last = fetch_all
  (1...rounds).each do |i|
    sleep 5
    puts "Check #{i + 1}..."
    current = fetch_all
    last = keep_unchanged_data(last, current)
  end

  stale = (last[:total_items].keys & last[:items].keys).sort!
  sorted = sort_data(last)

  puts ""
  puts "stale queue prediction"
  puts "======================"
  printf("%11s %11s %s\n", "total_items", "items", "queue")
  printf("%11s %11s %s\n", "-----------", "-----------", "--------------------")
  stale.each do |queue_name|
    items = sorted[:items][stale]
    total_items = sorted[:total_items][stale]
    printf("%11d %11d %s\n", total_items, items, queue_name)
  end
end


# ----------

parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options] <command>"
  opts.separator "Example: #{$0} -f shards.yml 11"

  opts.on("-f", "--file=FILENAME", "load kestrel server list from file (use '-' for stdin) (default: #{$options[:config_filename]})") do |filename|
    $options[:config_filename] = filename
  end
  opts.on("-p", "--port=N", "use port (default: #{$options[:port]})") do |port|
    $options[:port] = port.to_i
  end

  opts.separator ""
  opts.separator "Commands:"
  opts.separator "    all             show all of the stats summaries below (items, etc)"
  opts.separator "    items           show item counts per queue"
  opts.separator "    bytes           show byte counts per queue"
  opts.separator "    mem             show in-memory byte counts per queue"
  opts.separator "    min_age         show minimum age (msec) per queue"
  opts.separator "    max_age         show maximum age (msec) per queue"
  opts.separator ""
  opts.separator "    delete <name>   remove a queue across the cluster"
  opts.separator "    flush <name>    drain a queue across the cluster"
  opts.separator "    stale [rounds]  try to detect stale queues (default: 5 rounds)"
  opts.separator ""
end

parser.parse!(ARGV)

if ARGV.size < 1
  puts
  puts parser
  exit 1
end

server_file = $options[:config_filename] == "-" ? STDIN : File.open($options[:config_filename], "r")
$options[:server_list] = server_file.readlines.map { |line| line.chomp }
server_file.close

command = ARGV[0].downcase

if command == "all"
  $show = [ :items, :bytes, :mem_bytes, :min_age, :max_age ]
elsif command == "items"
  $show = [ :items ]
elsif command == "bytes"
  $show = [ :bytes ]
elsif command == "mem"
  $show = [ :mem_bytes ]
elsif command == "min_age"
  $show = [ :min_age ]
elsif command == "max_age"
  $show = [ :max_age ]
elsif command == "delete" && ARGV.size == 2
  queue_name = ARGV[1]
  print "Really delete #{queue_name}? (yes/no) "
  STDOUT.flush
  delete_all(queue_name) if STDIN.gets.chomp == 'yes'
  exit 0
elsif command == "flush" && ARGV.size == 2
  queue_name = ARGV[1]
  print "Really flush #{queue_name}? (yes/no) "
  STDOUT.flush
  flush_all(queue_name) if STDIN.gets.chomp == 'yes'
  exit 0
elsif command == "stale"
  rounds = ARGV[1] ? ARGV[1].to_i : 5
  find_stale(rounds)
  exit 0
end

if $show
  report_all(sort_data(fetch_all), $show)
  exit 0
else
  puts
  puts parser
  exit 1
end
